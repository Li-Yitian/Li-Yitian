<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>RabbitMQ</title>
      <link href="/2020/04/15/rabbitMQ/"/>
      <url>/2020/04/15/rabbitMQ/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.css"><script src="https://cdn.jsdelivr.net/npm/aplayer@latest/dist/APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="https://cdn.jsdelivr.net/npm/meting@1/dist/Meting.min"></script>    <div id="aplayer-sXvkhZgF" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="506668798" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="false" data-mutex="true" data-listmaxheight="340px" data-preload="auto" data-theme="#555"    ></div><h1 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h1><h3 id="什么是消息队列（mq）"><a href="#什么是消息队列（mq）" class="headerlink" title="什么是消息队列（mq）"></a>什么是消息队列（mq）</h3><blockquote><p>MQ（IBM MQ）代表消息队列，是一种应用程序对应用程序的通信方法；通过消息传递队列发送和接收消息数据，支持应用程序，系统，服务和文件之间的信息交换。这简化了业务应用程序的创建和维护</p></blockquote><p>消息队列是典型的消费者与生产者模型。</p><p>生产者不断向消息队列发送消息，消费者不断的从队列中获得消息。消息的产生和消费都是异步的，而且只关心消息的发送和接受，没有业务逻辑的入侵，这样就实现了生产者和消费者的解耦。</p><h3 id="AMQP和JMS"><a href="#AMQP和JMS" class="headerlink" title="AMQP和JMS"></a>AMQP和JMS</h3><p>MQ是消息通信的模型，并不是具体实现。现在实现MQ的有两种主流方式：AMQP、JMS。</p><h4 id="AMQP"><a href="#AMQP" class="headerlink" title="AMQP"></a>AMQP</h4><blockquote><p>AMQP，即Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准高级<a href="https://baike.baidu.com/item/消息/1619218" target="_blank" rel="noopener">消息</a>队列协议，是<a href="https://baike.baidu.com/item/应用层/4329788" target="_blank" rel="noopener">应用层</a>协议的一个开放标准，为面向消息的中间件设计。基于此协议的客户端与消息中间件可传递消息，并不受客户端/<a href="https://baike.baidu.com/item/中间件/452240" target="_blank" rel="noopener">中间件</a>不同产品，不同的开发语言等条件的限制。<a href="https://baike.baidu.com/item/Erlang" target="_blank" rel="noopener">Erlang</a>中的实现有<a href="https://baike.baidu.com/item/RabbitMQ" target="_blank" rel="noopener">RabbitMQ</a>等。</p></blockquote><h4 id="JMS"><a href="#JMS" class="headerlink" title="JMS"></a>JMS</h4><blockquote><p>JMS即Java消息服务（Java Message Service）应用程序接口，是一个<a href="https://baike.baidu.com/item/Java平台" target="_blank" rel="noopener">Java平台</a>中关于面向<a href="https://baike.baidu.com/item/消息中间件/5899771" target="_blank" rel="noopener">消息中间件</a>（MOM）的<a href="https://baike.baidu.com/item/API/10154" target="_blank" rel="noopener">API</a>，用于在两个应用程序之间，或<a href="https://baike.baidu.com/item/分布式系统/4905336" target="_blank" rel="noopener">分布式系统</a>中发送消息，进行<a href="https://baike.baidu.com/item/异步通信/2273903" target="_blank" rel="noopener">异步通信</a>。Java消息服务是一个与具体平台无关的API，绝大多数MOM提供商都对JMS提供支持。</p></blockquote><h3 id="AMQP与JMS区别"><a href="#AMQP与JMS区别" class="headerlink" title="AMQP与JMS区别"></a>AMQP与JMS区别</h3><ul><li><p>JMS是定义了统一的接口，来对消息操作进行统一；AMQP是通过规定协议来统一数据交互的格式</p></li><li><p>JMS限定了必须使用Java语言；AMQP只是协议，不规定实现方式，因此是跨语言的。</p></li><li><p>JMS规定了两种消息模型；而AMQP的消息模型更加丰富</p></li></ul><h4 id="常见的MQ产品"><a href="#常见的MQ产品" class="headerlink" title="常见的MQ产品"></a>常见的MQ产品</h4><ul><li>ActiveMQ：基于JMS</li><li>RabbitMQ：基于AMQP协议，erlang语言开发，稳定性好</li><li>RocketMQ：基于JMS，阿里巴巴产品，目前交由Apache基金会</li><li>Kafka：分布式消息系统，高吞吐量</li></ul><h2 id="RabbitMQ-1"><a href="#RabbitMQ-1" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><p><strong>安装教程</strong>：<a href="https://cloudlandboy.github.io/myNote/#/project/leyoumall/rabbitmq-install" target="_blank" rel="noopener">https://cloudlandboy.github.io/myNote/#/project/leyoumall/rabbitmq-install</a></p><h3 id="什么是RabbitMQ？"><a href="#什么是RabbitMQ？" class="headerlink" title="什么是RabbitMQ？"></a>什么是RabbitMQ？</h3><blockquote><p><strong>RabbitMQ</strong>是实现了高级消息队列协议（AMQP）的开源消息代理软件（亦称面向消息的中间件）。RabbitMQ服务器是用<a href="https://baike.baidu.com/item/Erlang" target="_blank" rel="noopener">Erlang</a>语言编写的，而集群和故障转移是构建在<a href="https://baike.baidu.com/item/开放电信平台" target="_blank" rel="noopener">开放电信平台</a>框架上的。所有主要的编程语言均有与代理接口通讯的客户端<a href="https://baike.baidu.com/item/库" target="_blank" rel="noopener">库</a>。</p><p>支持多种开发语言：java、python、ruby、.NET、PHP、C/C++、node.js等</p></blockquote><p>官网： <a href="http://www.rabbitmq.com/" target="_blank" rel="noopener">http://www.rabbitmq.com/</a></p><p>官方教程：<a href="http://www.rabbitmq.com/getstarted.html" target="_blank" rel="noopener">http://www.rabbitmq.com/getstarted.html</a></p><h3 id="了解即可的几种消息模型"><a href="#了解即可的几种消息模型" class="headerlink" title="了解即可的几种消息模型"></a>了解即可的几种消息模型</h3><h4 id="1、基本消息模型"><a href="#1、基本消息模型" class="headerlink" title="1、基本消息模型"></a>1、基本消息模型</h4><p><strong>基本消息示意图：</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-XRhEUg9q-1586701924284)(<a href="https://cdn.static.note.zzrfdsn.cn/images/project/leyoumall/1532762975546.png)]" target="_blank" rel="noopener">https://cdn.static.note.zzrfdsn.cn/images/project/leyoumall/1532762975546.png)]</a></p><p>基本消息模型相当于，你把邮件放到邮筒里，然后rabbitmq充当邮局、邮筒和邮递员，只不过rabbitmq并不对数据做处理。rabbitmq只会做数据存储，转发数据消息的二进制块。最终处理数据的是消费者。</p><p>可以设置一个消息确定机制（ACK），来确定你的数据有没有被处理掉。</p><h4 id="2、work消息模型"><a href="#2、work消息模型" class="headerlink" title="2、work消息模型"></a><strong>2、work消息模型</strong></h4><p><strong>work示意图：</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3RhdGljLm5vdGUuenpyZmRzbi5jbi9pbWFnZXMvcHJvamVjdC9sZXlvdW1hbGwvMTUzMjc2NTE5NzI3Ny5wbmc?x-oss-process=image/format,png" alt="1532765197277" loading="lazy"></p><p>任务队列，一个生产者有多个消费者，主要思想是避免执行资源密集型任务时，必须等待它执行完成。相反我们可以稍后完成任务，我们将任务封装为消息并将其发送到队列。在后台邮箱的工作进程将获取任务并最终执行作业。当你运行许多消费者时，任务将在他们之间共享，但是一个消息只能被一个消费者共享。</p><p><strong>面试题</strong>：<strong>避免消息堆积？</strong></p><ul><li><p>采用workqueue，多个消费者监听同一队列。</p></li><li><p>接收到消息以后，而是通过线程池，异步消费。</p></li></ul><h5 id="能者多劳"><a href="#能者多劳" class="headerlink" title="能者多劳"></a>能者多劳</h5><ul><li><p>消费者1比消费者2的效率要低，一次任务的耗时较长</p></li><li><p>然而两人最终消费的消息数量是一样的</p></li><li><p>消费者2大量时间处于空闲状态，消费者1一直忙碌</p><p>现在的状态属于是把任务平均分配，正确的做法应该是消费越快的人，消费的越多。</p><p>怎么实现呢？</p><p>我们可以使用basicQos方法和prefetchCount = 1设置。 这告诉RabbitMQ一次不要向工作人员发送多于一条消息。 或者换句话说，不要向工作人员发送新消息，直到它处理并确认了前一个消息。 相反，它会将其分派给不是仍然忙碌的下一个工作人员。</p></li></ul><h4 id="3、订阅模型"><a href="#3、订阅模型" class="headerlink" title="3、订阅模型"></a><strong>3、订阅模型</strong></h4><p>work只能传递给一个消费者，而订阅模型可以一个消息多个消费者使用。</p><p>这种模式被称为“发布/订阅”。</p><p><strong>订阅模型示意图：</strong><br><img src="https://img-blog.csdnimg.cn/20200412224000323.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk4ODYwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>解读：</p><p>1、1个P生产者，多个消费者</p><p>2、1个X交换机，生产者把消费发送到交换机，由交换机发送给指定队列</p><p>3、多个消息队列，每个消费者绑定一个交换机</p><p>4、每个队列都只有一个消费者。</p><p>5、生产者发送消息，经过交换机到达队列，实现一个消息被多个消费者获取。</p><p>X（Exchange）：交换机，一方面：接受生产者发送的消息。另一方面：知道如何处理消息，例如发送给某个特别的队列，递交给所有队列，或是将消息丢弃。到底如何操作取决于Exchange的类型。</p><p><strong>Exchange类型有一下几种：</strong></p><ul><li><strong>Fanout：</strong>广播：将消息交给所有绑定到交换机的队列</li><li><strong>Direct:</strong> 定向，把消息交给符合指定的routing key 的队列</li><li><strong>Topic:</strong> 通配符，把消息交给符合routing pattern（路由模式）的队列</li></ul><p>【<strong>注</strong>】Exchange只负责转发消息，不具被存储消息的能力，如果没有如何队列与Exchange绑定或者没有符合路由规则的队列，那么消息会丢失。</p><h4 id="订阅模型-Fanout"><a href="#订阅模型-Fanout" class="headerlink" title="-订阅模型-Fanout"></a>-订阅模型-Fanout</h4><p>Fanout，也称之为：广播</p><p>Fanout流程图：</p><p><img src="https://img-blog.csdnimg.cn/20200412223438181.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk4ODYwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>在广播模式下，消息发送流程是这样的：</p><ul><li>可以有多个消费者</li><li>每个<strong>消费者有自己的queue</strong>（队列）</li><li>每个<strong>队列都要绑定到Exchange</strong>（交换机）</li><li><strong>生产者发送的消息，只能发送到交换机</strong>，交换机来决定要发给哪个队列，生产者无法决定。</li><li>交换机把消息发送给绑定过的所有队列</li><li>队列的消费者都能拿到消息。实现一条消息被多个消费者消费</li></ul><h4 id="订阅模型-Direct"><a href="#订阅模型-Direct" class="headerlink" title="-订阅模型-Direct"></a>-订阅模型-Direct</h4><p>有选择性的接收消息</p><p>在订阅模式中，生产者发布消息，所有消费者都可以获取所有消息。</p><p>在路由模式中，我们将添加一个功能 - 我们将只能订阅一部分消息。 例如，我们只能将重要的错误消息引导到日志文件（以节省磁盘空间），同时仍然能够在控制台上打印所有日志消息。</p><p>但是，在某些场景下，我们希望不同的消息被不同的队列消费。这时就要用到Direct类型的Exchange。</p><p>在Direct模型下，队列与交换机的绑定，不能是任意绑定了，而是要指定一个RoutingKey（路由key）</p><p>消息的发送方在向Exchange发送消息时，也必须指定消息的routing key。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3RhdGljLm5vdGUuenpyZmRzbi5jbi9pbWFnZXMvcHJvamVjdC9sZXlvdW1hbGwvMTUzMjc2NjQzNzc4Ny5wbmc?x-oss-process=image/format,png" alt="1532766437787" loading="lazy"></p><p>P：生产者，向Exchange发送消息，发送消息时，会指定一个routing key。</p><p>X：Exchange（交换机），接收生产者的消息，然后把消息递交给 与routing key完全匹配的队列</p><p>C1：消费者，其所在队列指定了需要routing key 为 error 的消息</p><p>C2：消费者，其所在队列指定了需要routing key 为 info、error、warning 的消息</p><h4 id="订阅模型-Topic"><a href="#订阅模型-Topic" class="headerlink" title="-订阅模型-Topic"></a>-订阅模型-Topic</h4><p><code>Topic</code>类型的<code>Exchange</code>与<code>Direct</code>相比，都是可以根据<code>RoutingKey</code>把消息路由到不同的队列。只不过<code>Topic</code>类型<code>Exchange</code>可以让队列在绑定<code>Routing key</code> 的时候使用通配符！</p><p>Routingkey<code>一般都是有一个或多个单词组成，多个单词之间以”.”分割，例如：</code>item.insert</p><p>通配符规则：</p><pre><code>`#`：匹配一个或多个词`*`：匹配不多不少恰好1个词Copy to clipboardErrorCopied</code></pre><p>举例：</p><pre><code>`audit.#`：能够匹配`audit.irs.corporate` 或者 `audit.irs``audit.*`：只能匹配`audit.irs`</code></pre><p><img src="https://img-blog.csdnimg.cn/20200412223500254.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk4ODYwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><p>在这个例子中，我们将发送所有描述动物的消息。消息将使用由三个字（两个点）组成的routing key发送。路由关键字中的第一个单词将描述速度，第二个颜色和第三个种类：<code>速度.颜色.种类</code>。</p><p>我们创建了三个绑定：Q1绑定了<code>* .orange.*</code>，Q2绑定了<code>*.*.rabbit</code>和<code>lazy.＃</code>。</p><p>Q1匹配所有的橙色动物。</p><p>Q2匹配关于兔子以及懒惰动物的消息。</p><h4 id="持久化"><a href="#持久化" class="headerlink" title="持久化"></a>持久化</h4><p><strong>如何避免消息丢失？</strong></p><p>1、消费者的ACK机制。可以防止消费者丢失消息。</p><p>2、但是，如果在消费者消费之前，MQ就宕机了，消息就没了。</p><p>要将消息持久化，前提是：队列、Exchange都持久化</p><p><strong>交换机持久化</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3RhdGljLm5vdGUuenpyZmRzbi5jbi9pbWFnZXMvcHJvamVjdC9sZXlvdW1hbGwvMTUzMjc2Njk1MTQzMi5wbmc?x-oss-process=image/format,png" alt="1532766951432" loading="lazy"></p><p><strong>队列持久化</strong></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uc3RhdGljLm5vdGUuenpyZmRzbi5jbi9pbWFnZXMvcHJvamVjdC9sZXlvdW1hbGwvMTUzMjc2Njk4MTIzMC5wbmc?x-oss-process=image/format,png" alt="1532766981230" loading="lazy"></p><p><strong>消息持久化</strong></p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-K3YoRcnh-1586701924297)(<a href="https://cdn.static.note.zzrfdsn.cn/images/project/leyoumall/1532767057491.png)]" target="_blank" rel="noopener">https://cdn.static.note.zzrfdsn.cn/images/project/leyoumall/1532767057491.png)]</a></p><h3 id="Spring-AMQP"><a href="#Spring-AMQP" class="headerlink" title="Spring AMQP"></a>Spring AMQP</h3><p><strong>官方文档</strong>：<a href="https://spring.io/projects/spring-amqp#overview" target="_blank" rel="noopener">https://spring.io/projects/spring-amqp#overview</a><br><img src="https://img-blog.csdnimg.cn/20200412223600536.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk4ODYwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><blockquote><p>SpringAMQP项目将核心Spring概念应用于基于AMQP的消息传递解决方案的开发。它提供了一个“模板”作为发送和接收消息的高级抽象。它还提供了对带有“侦听器容器”的消息驱动POJO的支持。这些库简化了AMQP资源的管理，同时促进了依赖注入和声明式配置的使用。在所有这些情况下，您将看到与Spring框架中JMS支持的相似之处。该项目由两个部分组成：Spring-AMQP是基本抽象，Spring-Rabbit是RabbitMQ实现。</p></blockquote><p><img src="https://img-blog.csdnimg.cn/20200412223544593.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80Mzk4ODYwMA==,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述" loading="lazy"></p><blockquote><h4 id="特征"><a href="#特征" class="headerlink" title="特征"></a>特征</h4><ul><li>用于异步处理入站消息的侦听器容器</li><li>用于发送和接收信息的RabbitTemplate</li><li>用于自动声明队列、交换和绑定的RabbitAdmin</li></ul></blockquote><p>【<strong>意</strong>】 Spring-amqp是对AMQP协议的抽象实现，而spring-rabbit 是对协议的具体实现，也是目前的唯一实现。底层使用的就是RabbitMQ。</p><p>【<strong>使用</strong>】</p><h5 id="1、导入依赖和配置"><a href="#1、导入依赖和配置" class="headerlink" title="1、导入依赖和配置"></a>1、导入依赖和配置</h5><p>添加AMQP的启动器</p><pre class="line-numbers language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>spring-boot-starter-amqp<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置RabbitMQ的地址</p><pre class="line-numbers language-java"><code class="language-java">spring<span class="token operator">:</span>  rabbitmq<span class="token operator">:</span>    host<span class="token operator">:</span> <span class="token number">172.16</span><span class="token punctuation">.</span><span class="token number">145.141</span>    username<span class="token operator">:</span> root    password<span class="token operator">:</span> root    virtual<span class="token operator">-</span>host<span class="token operator">:</span> <span class="token operator">/</span>root<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="2、发送消息，AmqpTemplate"><a href="#2、发送消息，AmqpTemplate" class="headerlink" title="2、发送消息，AmqpTemplate"></a>2、发送消息，AmqpTemplate</h5><p>Spring最擅长的事情就是封装，把他人的框架进行封装和整合。</p><p>Spring为AMQP提供了统一的消息处理模板：AmqpTemplate，非常方便的发送消息，其发送方法：</p><p>[外链图片转存失败,源站可能有防盗链机制,建议将图片保存下来直接上传(img-CYhrjAg7-1586701924304)(<a href="https://cdn.static.note.zzrfdsn.cn/images/project/leyoumall/1527090258083.png)]" target="_blank" rel="noopener">https://cdn.static.note.zzrfdsn.cn/images/project/leyoumall/1527090258083.png)]</a></p><p>红框圈起来的是比较常用的3个方法，分别是：</p><ul><li>指定交换机、RoutingKey和消息体</li><li>指定消息</li><li>指定RoutingKey和消息，会向默认的交换机发送消息</li></ul><h5 id="3、接受消息，监听者"><a href="#3、接受消息，监听者" class="headerlink" title="3、接受消息，监听者"></a>3、接受消息，监听者</h5><p>在SpringAmqp中，对消息的消费者进行了封装和抽象，一个普通的JavaBean中的普通方法，只要通过简单的注解，就可以成为一个消费者。</p><pre class="line-numbers language-java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Listener</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@RabbitListener</span><span class="token punctuation">(</span>bindings <span class="token operator">=</span> <span class="token annotation punctuation">@QueueBinding</span><span class="token punctuation">(</span>            value <span class="token operator">=</span> <span class="token annotation punctuation">@Queue</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"spring.test.queue"</span><span class="token punctuation">,</span> durable <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            exchange <span class="token operator">=</span> <span class="token annotation punctuation">@Exchange</span><span class="token punctuation">(</span>                    value <span class="token operator">=</span> <span class="token string">"spring.test.exchange"</span><span class="token punctuation">,</span>                    ignoreDeclarationExceptions <span class="token operator">=</span> <span class="token string">"true"</span><span class="token punctuation">,</span>                    type <span class="token operator">=</span> ExchangeTypes<span class="token punctuation">.</span>TOPIC            <span class="token punctuation">)</span><span class="token punctuation">,</span>            key <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"#.#"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">listen</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span><span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到消息："</span> <span class="token operator">+</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><p><code>@Componet</code>：类上的注解，注册到Spring容器</p><pre><code>@RabbitListener ：方法上的注解，声明这个方法是一个消费者方法，需要指定下面的属性：</code></pre><pre><code>bindings：指定绑定关系，可以有多个。值是@QueueBinding的数组。@QueueBinding包含下面属性：</code></pre></li></ul><p>  包含下面属性：</p><ul><li><code>value</code>：这个消费者关联的队列。值是<code>@Queue</code>，代表一个队列</li><li><code>exchange</code>：队列所绑定的交换机，值是<code>@Exchange</code>类型</li><li><code>key</code>：队列和交换机绑定的<code>RoutingKey</code></li></ul><p>类似listen这样的方法在一个类中可以写多个，就代表多个消费者。</p>]]></content>
      
      
      <categories>
          
          <category> 消息队列 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 中间件 </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
